use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub struct GameResource {
    pub id: u32,   // 资源ID
    pub value: i64, // 资源值
    pub max: i64,   // 资源上限
    pub per_tick: i64,  // 每秒资源增量
    pub interval_ms: u64,  // 资源间隔（毫秒）
    pub last_tick_ms: u64, // 上一次刷新时刻（毫秒）
}

impl GameResource {

     #[inline]
    pub fn next_tick(&self) -> u64 {
        self.last_tick_ms + self.interval_ms
    }

    #[inline]
    pub fn set_value(&mut self) {
        self.value = (self.value + self.per_tick).min(self.max);
    }
}

// 资源管理
pub struct GameResourceManagement {
    pub resources: Vec<GameResource>,
}
impl GameResourceManagement { 

}

async fn _schedule_tick(){
    AAs

}sasasas




fn main() {
    let mut resources = vec![
        GameResource { id: 1, value: 0, max: 100, per_tick: 1, interval_ms: 1000, last_tick_ms: 0 },
        GameResource { id: 2, value: 0, max: 100, per_tick: 1, interval_ms: 1000, last_tick_ms: 0 },
        GameResource { id: 3, value: 0, max: 100, per_tick: 1, interval_ms: 2000, last_tick_ms: 0 },
    ];


}




















// 添加
cargo add A
// 运行
cargo run


[package]
name = "dqwm"
version = "0.1.0"
edition = "2024"


[dependencies]
# rhai = { version = "1.16", features = ["sync", "serde", "only_i64"] }
# serde = { version = "1.0", features = ["derive"] }
# serde_json = "1.0"
# thiserror = "1.0"
# anyhow = "1.0"
eframe = { version = "0.33.0", features = ["glow"] }
egui = "0.33.0"   # 
egui_extras = "0.33.0"




#[derive(Debug, Clone, Default, PartialEq)]
struct GameResource {
    id: i32, // 唯一标识符
    name: String, // 资源名称
    description: String, // 资源描述
    value: i128, // 资源值
    max_value: i128, // 资源最大值
    change_value: f64, // 资源变化值
    current_interval: i8, // 当前资源刷新间隔
    interval: i8, // 资源刷新间隔
    last_refresh_time: i64, // 最后一次刷新时间
}


// 来源
// #[derive(Debug, Clone, Default, PartialEq)]
// struct Bonus {
//     id: i32, // 唯一标识符
//     name: String, // 来源名称
//     target_ids: Vec<i32>, // 目标资源标识符
//     description: String, // 来源描述
//     value: i128, // 来源值
//     rate: f64, // 来源比例
//     area_name: String, // 区域名称
// }

// 来源管理
pub struct BonusManager {
    inner: Vec<Bonus>, // 来源列表
}












/// 1. 策划配表，全局只读
#[derive(Debug, Clone, Copy)]
pub struct BaseUnitTemp {
    pub id: u32,                // id
    pub name: &'static str,     // 名字
    pub base_atk: u128,         // 攻击
    pub base_hp: u128,          // 生命
    pub base_def: u128,         // 防御
    pub base_crit_rate: f64,    // 暴击率
    pub base_crit_damage: f64,  // 暴击伤害
    pub base_hit_rate: f64,     // 命中率
    pub base_dodge_rate: f64,   // 闪避率
    pub base_attack_speed: f64, // 攻击速度
    pub base_life_steal: f64,   // 生命偷取
}

/// 2. 账号维度：在基础值上叠加养成、装备、科技等加成
///   只存“当前值”，不存历史 delta
#[derive(Debug, Clone)]
pub struct UnitTemp {
    pub base_temp_id: u32, // 对应 BaseUnitTemp.id
    pub name: String,
    pub atk: u128,         // 当前攻击
    pub hp: u128,
    pub def: u128,
    pub crit_rate: f64,    // 暴击率
    pub crit_damage: f64,  // 暴击伤害
    pub hit_rate: f64,     // 命中率
    pub dodge_rate: f64,   // 闪避率
    pub attack_speed: f64, // 攻击速度
    pub life_steal: f64,   // 生命偷取
}


#[derive(Debug, Clone)]
pub struct Unit {
    pub temp_id: u32,
    pub name: String,
    pub atk: u128,
    pub hp: u128,
    pub def: u128,
    pub crit_rate: f64,    // 暴击率
    pub crit_damage: f64,  // 暴击伤害
    pub hit_rate: f64,     // 命中率
    pub dodge_rate: f64,   // 闪避率
    pub attack_speed: f64, // 攻击速度
    pub life_steal: f64,   // 生命偷取
}
 






 // 动态执行

 use rhai::{Engine, Map, AST};
use std::time::Instant;

fn main() {
    let engine = Engine::new();
    let ast: AST = engine
        .compile(r#"
            if lv > 10 { #{"1001": 5*lv, "1005": 50*lv} }
            else       { #{"1001": 2*lv, "1005": 20*lv} }
        "#)
        .unwrap();

    let mut scope = rhai::Scope::new();
    // 预热一次，避免 AST 懒加载干扰
    scope.push("lv", 15_i64);
    let _: Map = engine.eval_ast_with_scope(&mut scope, &ast).unwrap();

    const N: usize = 10000;
    let start = Instant::now();

    for _ in 0..N {
        // 每次只换变量，不重新编译
        scope.push("lv", 15_i64);
        let _: Map = engine.eval_ast_with_scope(&mut scope, &ast).unwrap();
    }

    let elapsed = start.elapsed();
    println!(
        "1000 次总耗时 {:?}，单次平均 {:?}",
        elapsed,
        elapsed / N as u32
    );
}