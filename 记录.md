# egui 学习笔记

# 启动

```sh
# 桌面启动
cargo run --features desktop
cargo run --features desktop --release
cargo run --release
cargo build --release # 打包
# 打包安卓so文件
cargo ndk -t arm64-v8a -o "D:\DPFS\workspace\android\dqwm\app\src\main\jniLibs" build --release
cargo ndk -t x86_64 -o "D:\DPFS\workspace\android\dqwm\app\src\main\jniLibs" build --release

# 备用
cargo ndk -t i686-linux-android -o "D:\DPFS\workspace\android\dqwm\app\src\main\jniLibs" build --release
cargo ndk -t arm64-v8a -o ./jniLibs build --release --features android
cargo ndk -t x86_64 -o ./jniLibs build --release --features android
```

# 配置中文字体

```rust
/// 字体加载专用函数
fn load_fonts(ctx: &egui::Context) {
    // 创建默认字体配置容器
    let mut fonts = egui::FontDefinitions::default();

    // 注册自定义字体数据（需提前放置simsun.ttc在项目根目录）
    fonts.font_data.insert(
        "my_font".to_owned(), // 字体标识名
        Arc::new(
            // 使用Arc实现线程安全共享
            egui::FontData::from_owned(
                // 转换字体数据为egui格式
                include_bytes!("../simsun.ttc") // 编译时嵌入字体文件
                    .to_vec(), // 转为Vec<u8>
            ),
        ),
    );

    // 配置比例字体家族（用于常规文本）
    fonts
        .families // 访问字体家族集合
        .entry(egui::FontFamily::Proportional) // 获取比例字体入口
        .or_default() // 不存在则创建默认列表
        .insert(0, "my_font".to_owned()); // 插入到最高优先级

    // 配置等宽字体家族（用于代码/表格）
    fonts
        .families
        .entry(egui::FontFamily::Monospace) // 获取等宽字体入口
        .or_default()
        .push("my_font".to_owned()); // 追加到列表末尾

    // 将最终配置应用到egui上下文
    ctx.set_fonts(fonts);
}
```

默认字体路径
D:\DPFS\Rust\.cargo\registry\src\mirrors.ustc.edu.cn-38d0e5eb5da2abae\bevy_text-0.17.2\src
D:\DPFS\Rust\.cargo\registry\src\mirrors.ustc.edu.cn-38d0e5eb5da2abae\epaint_default_fonts-0.33.0\fonts

```json
settings.json

{
  "rust-analyzer.linkedProjects": [
    "./Cargo.toml"
  ],
  "rust-analyzer.cargo.target": "aarch64-linux-android",
  "[rust]": {
    "editor.formatOnSave": true
  }
}















 // // 按下
                    // callback(
                    //     event::Event::WindowEvent {
                    //         window_id,
                    //         event: event::WindowEvent::KeyboardInput {
                    //             device_id: event::DeviceId(DeviceId(0)),
                    //             event: KeyEvent {
                    //                 physical_key: PhysicalKey::Code(KeyCode::Enter),
                    //                 logical_key: Key::Named(NamedKey::Enter),
                    //                 location: KeyLocation::Standard,
                    //                 state: ElementState::Pressed,
                    //                 repeat: false,
                    //                 text: None,
                    //                 platform_specific: KeyEventExtra {},
                    //             },
                    //             is_synthetic: false,
                    //         },
                    //     },
                    //     self.window_target(),
                    // );
                    // return InputStatus::Handled;










```

# 解决 egui 安卓不能输入的问题

D:\DPFS\Rust\.cargo\registry\src\mirrors.ustc.edu.cn-38d0e5eb5da2abae\winit-0.30.12\src\platform_impl\android\mod.rs

修改适配安卓输入。

## 优化

```rust
InputEvent::TextEvent(text) => {
                let window_id = window::WindowId(WindowId);
                if text.text.starts_with(EMPTY_SENTINEL) {
                    return InputStatus::Handled; // 本次是哨兵，跳过不上报
                }
                match text.text.as_str() {
                    // 输入回车
                    "\n" => {
                        for state in [ElementState::Pressed, ElementState::Released] {
                            callback(
                                event::Event::WindowEvent {
                                    window_id,
                                    event: event::WindowEvent::KeyboardInput {
                                        device_id: event::DeviceId(DeviceId(0)),
                                        event: KeyEvent {
                                            physical_key: PhysicalKey::Code(KeyCode::Enter),
                                            logical_key: Key::Named(NamedKey::Enter),
                                            location: KeyLocation::Standard,
                                            state: state,
                                            repeat: false,
                                            text: None,
                                            platform_specific: KeyEventExtra {},
                                        },
                                        is_synthetic: false,
                                    },
                                },
                                self.window_target(),
                            );
                        }
                    }
                    // 输入退格
                    "" => {
                        for state in [ElementState::Pressed, ElementState::Released] {
                            callback(
                                event::Event::WindowEvent {
                                    window_id,
                                    event: event::WindowEvent::KeyboardInput {
                                        device_id: event::DeviceId(DeviceId(0)),
                                        event: KeyEvent {
                                            physical_key: PhysicalKey::Code(KeyCode::Backspace),
                                            logical_key: Key::Named(NamedKey::Backspace),
                                            location: KeyLocation::Standard,
                                            state: state,
                                            repeat: false,
                                            text: None,
                                            platform_specific: KeyEventExtra {},
                                        },
                                        is_synthetic: false,
                                    },
                                },
                                self.window_target(),
                            );
                        }
                    }
                    // 输入其他字符
                    _ => {
                        let enabled = event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::Ime(event::Ime::Enabled),
                        };
                        callback(enabled, self.window_target());

                        let commit = event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::Ime(event::Ime::Commit(text.text.clone())),
                        };
                        callback(commit, self.window_target());

                        let disabled = event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::Ime(event::Ime::Disabled),
                        };
                        callback(disabled, self.window_target());

                        android_app.set_text_input_state(android_activity::input::TextInputState {
                            text: EMPTY_SENTINEL.to_string(),
                            selection: TextSpan { start: 0, end: 1 },
                            compose_region: None,
                        });
                    }
                }
            }

```

## 部分

```rust
/* ====  自己加的  开始  ==== */
use crate::event::{ElementState, Ime, KeyEvent};
use crate::keyboard::{Key, KeyCode, KeyLocation, NamedKey, PhysicalKey};
use android_activity::input::{TextInputState, TextSpan};
const EMPTY_SENTINEL: char = '\u{FFFF}';
/* ====  自己加的 结束    ==== */

InputEvent::TextEvent(text) => {
                let window_id = window::WindowId(WindowId);
                if text.text.starts_with(EMPTY_SENTINEL) {
                    return InputStatus::Handled; // 本次是哨兵，跳过不上报
                }
                // 输入回车
                if text.text == "\n" {
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Enter),
                                    logical_key: Key::Named(NamedKey::Enter),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Pressed,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Enter),
                                    logical_key: Key::Named(NamedKey::Enter),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Released,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    return InputStatus::Handled;
                }
                // 退格键
                if text.text.is_empty() {
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Backspace),
                                    logical_key: Key::Named(NamedKey::Backspace),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Pressed,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Backspace),
                                    logical_key: Key::Named(NamedKey::Backspace),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Released,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    return InputStatus::Handled;
                }

                let enabled = event::Event::WindowEvent {
                    window_id,
                    event: event::WindowEvent::Ime(event::Ime::Enabled),
                };
                callback(enabled, self.window_target());

                let commit = event::Event::WindowEvent {
                    window_id,
                    event: event::WindowEvent::Ime(event::Ime::Commit(text.text.clone())),
                };
                callback(commit, self.window_target());

                let disabled = event::Event::WindowEvent {
                    window_id,
                    event: event::WindowEvent::Ime(event::Ime::Disabled),
                };
                callback(disabled, self.window_target());

                android_app.set_text_input_state(android_activity::input::TextInputState {
                    text: EMPTY_SENTINEL.to_string(),
                    selection: TextSpan { start: 0, end: 1 },
                    compose_region: None,
                });
            }



```

## 完整

```rust
use std::cell::Cell;
use std::collections::VecDeque;
use std::hash::Hash;
use std::marker::PhantomData;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{mpsc, Arc, Mutex};
use std::time::{Duration, Instant};

use android_activity::input::{InputEvent, KeyAction, Keycode, MotionAction};
use android_activity::{
    AndroidApp, AndroidAppWaker, ConfigurationRef, InputStatus, MainEvent, Rect,
};
use tracing::{debug, trace, warn};

use crate::cursor::Cursor;
use crate::dpi::{PhysicalPosition, PhysicalSize, Position, Size};
use crate::error;
use crate::error::EventLoopError;
use crate::event::{self, Force, InnerSizeWriter, StartCause};
use crate::event_loop::{self, ActiveEventLoop as RootAEL, ControlFlow, DeviceEvents};
use crate::platform::pump_events::PumpStatus;
use crate::platform_impl::Fullscreen;
use crate::window::{
    self, CursorGrabMode, CustomCursor, CustomCursorSource, ImePurpose, ResizeDirection, Theme,
    WindowButtons, WindowLevel,
};
/* ====  自己加的  开始  ==== */
use crate::event::{ElementState, Ime, KeyEvent};
use crate::keyboard::{Key, KeyCode, KeyLocation, NamedKey, PhysicalKey};
use android_activity::input::{TextInputState, TextSpan};
const EMPTY_SENTINEL: char = '\u{FFFF}';
/* ====  自己加的 结束    ==== */

mod keycodes;

pub(crate) use crate::cursor::{
    NoCustomCursor as PlatformCustomCursor, NoCustomCursor as PlatformCustomCursorSource,
};
pub(crate) use crate::icon::NoIcon as PlatformIcon;

static HAS_FOCUS: AtomicBool = AtomicBool::new(true);

/// Returns the minimum `Option<Duration>`, taking into account that `None`
/// equates to an infinite timeout, not a zero timeout (so can't just use
/// `Option::min`)
fn min_timeout(a: Option<Duration>, b: Option<Duration>) -> Option<Duration> {
    a.map_or(b, |a_timeout| {
        b.map_or(Some(a_timeout), |b_timeout| Some(a_timeout.min(b_timeout)))
    })
}

struct PeekableReceiver<T> {
    recv: mpsc::Receiver<T>,
    first: Option<T>,
}

impl<T> PeekableReceiver<T> {
    pub fn from_recv(recv: mpsc::Receiver<T>) -> Self {
        Self { recv, first: None }
    }

    pub fn has_incoming(&mut self) -> bool {
        if self.first.is_some() {
            return true;
        }
        match self.recv.try_recv() {
            Ok(v) => {
                self.first = Some(v);
                true
            }
            Err(mpsc::TryRecvError::Empty) => false,
            Err(mpsc::TryRecvError::Disconnected) => {
                warn!("Channel was disconnected when checking incoming");
                false
            }
        }
    }

    pub fn try_recv(&mut self) -> Result<T, mpsc::TryRecvError> {
        if let Some(first) = self.first.take() {
            return Ok(first);
        }
        self.recv.try_recv()
    }
}

#[derive(Clone)]
struct SharedFlagSetter {
    flag: Arc<AtomicBool>,
}
impl SharedFlagSetter {
    pub fn set(&self) -> bool {
        self.flag
            .compare_exchange(false, true, Ordering::AcqRel, Ordering::Relaxed)
            .is_ok()
    }
}

struct SharedFlag {
    flag: Arc<AtomicBool>,
}

// Used for queuing redraws from arbitrary threads. We don't care how many
// times a redraw is requested (so don't actually need to queue any data,
// we just need to know at the start of a main loop iteration if a redraw
// was queued and be able to read and clear the state atomically)
impl SharedFlag {
    pub fn new() -> Self {
        Self {
            flag: Arc::new(AtomicBool::new(false)),
        }
    }

    pub fn setter(&self) -> SharedFlagSetter {
        SharedFlagSetter {
            flag: self.flag.clone(),
        }
    }

    pub fn get_and_reset(&self) -> bool {
        self.flag.swap(false, std::sync::atomic::Ordering::AcqRel)
    }
}

#[derive(Clone)]
pub struct RedrawRequester {
    flag: SharedFlagSetter,
    waker: AndroidAppWaker,
}

impl RedrawRequester {
    fn new(flag: &SharedFlag, waker: AndroidAppWaker) -> Self {
        RedrawRequester {
            flag: flag.setter(),
            waker,
        }
    }

    pub fn request_redraw(&self) {
        if self.flag.set() {
            // Only explicitly try to wake up the main loop when the flag
            // value changes
            self.waker.wake();
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct KeyEventExtra {}

pub struct EventLoop<T: 'static> {
    pub(crate) android_app: AndroidApp,
    window_target: event_loop::ActiveEventLoop,
    redraw_flag: SharedFlag,
    user_events_sender: mpsc::Sender<T>,
    user_events_receiver: PeekableReceiver<T>, // must wake looper whenever something gets sent
    loop_running: bool,                        // Dispatched `NewEvents<Init>`
    running: bool,
    pending_redraw: bool,
    cause: StartCause,
    ignore_volume_keys: bool,
    combining_accent: Option<char>,
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct PlatformSpecificEventLoopAttributes {
    pub(crate) android_app: Option<AndroidApp>,
    pub(crate) ignore_volume_keys: bool,
}

impl Default for PlatformSpecificEventLoopAttributes {
    fn default() -> Self {
        Self {
            android_app: Default::default(),
            ignore_volume_keys: true,
        }
    }
}

impl<T: 'static> EventLoop<T> {
    pub(crate) fn new(
        attributes: &PlatformSpecificEventLoopAttributes,
    ) -> Result<Self, EventLoopError> {
        let (user_events_sender, user_events_receiver) = mpsc::channel();

        let android_app = attributes.android_app.as_ref().expect(
            "An `AndroidApp` as passed to android_main() is required to create an `EventLoop` on \
             Android",
        );
        let redraw_flag = SharedFlag::new();

        Ok(Self {
            android_app: android_app.clone(),
            window_target: event_loop::ActiveEventLoop {
                p: ActiveEventLoop {
                    app: android_app.clone(),
                    control_flow: Cell::new(ControlFlow::default()),
                    exit: Cell::new(false),
                    redraw_requester: RedrawRequester::new(
                        &redraw_flag,
                        android_app.create_waker(),
                    ),
                },
                _marker: PhantomData,
            },
            redraw_flag,
            user_events_sender,
            user_events_receiver: PeekableReceiver::from_recv(user_events_receiver),
            loop_running: false,
            running: false,
            pending_redraw: false,
            cause: StartCause::Init,
            ignore_volume_keys: attributes.ignore_volume_keys,
            combining_accent: None,
        })
    }

    fn single_iteration<F>(&mut self, main_event: Option<MainEvent<'_>>, callback: &mut F)
    where
        F: FnMut(event::Event<T>, &RootAEL),
    {
        trace!("Mainloop iteration");

        let cause = self.cause;
        let mut pending_redraw = self.pending_redraw;
        let mut resized = false;

        callback(event::Event::NewEvents(cause), self.window_target());

        if let Some(event) = main_event {
            trace!("Handling main event {:?}", event);

            match event {
                MainEvent::InitWindow { .. } => {
                    callback(event::Event::Resumed, self.window_target());
                }
                MainEvent::TerminateWindow { .. } => {
                    callback(event::Event::Suspended, self.window_target());
                }
                MainEvent::WindowResized { .. } => resized = true,
                MainEvent::RedrawNeeded { .. } => pending_redraw = true,
                MainEvent::ContentRectChanged { .. } => {
                    warn!("TODO: find a way to notify application of content rect change");
                }
                MainEvent::GainedFocus => {
                    HAS_FOCUS.store(true, Ordering::Relaxed);
                    callback(
                        event::Event::WindowEvent {
                            window_id: window::WindowId(WindowId),
                            event: event::WindowEvent::Focused(true),
                        },
                        self.window_target(),
                    );
                }
                MainEvent::LostFocus => {
                    HAS_FOCUS.store(false, Ordering::Relaxed);
                    callback(
                        event::Event::WindowEvent {
                            window_id: window::WindowId(WindowId),
                            event: event::WindowEvent::Focused(false),
                        },
                        self.window_target(),
                    );
                }
                MainEvent::ConfigChanged { .. } => {
                    let monitor = MonitorHandle::new(self.android_app.clone());
                    let old_scale_factor = monitor.scale_factor();
                    let scale_factor = monitor.scale_factor();
                    if (scale_factor - old_scale_factor).abs() < f64::EPSILON {
                        let new_inner_size = Arc::new(Mutex::new(
                            MonitorHandle::new(self.android_app.clone()).size(),
                        ));
                        let event = event::Event::WindowEvent {
                            window_id: window::WindowId(WindowId),
                            event: event::WindowEvent::ScaleFactorChanged {
                                inner_size_writer: InnerSizeWriter::new(Arc::downgrade(
                                    &new_inner_size,
                                )),
                                scale_factor,
                            },
                        };
                        callback(event, self.window_target());
                    }
                }
                MainEvent::LowMemory => {
                    callback(event::Event::MemoryWarning, self.window_target());
                }
                MainEvent::Start => {
                    // XXX: how to forward this state to applications?
                    warn!("TODO: forward onStart notification to application");
                }
                MainEvent::Resume { .. } => {
                    debug!("App Resumed - is running");
                    self.running = true;
                }
                MainEvent::SaveState { .. } => {
                    // XXX: how to forward this state to applications?
                    // XXX: also how do we expose state restoration to apps?
                    warn!("TODO: forward saveState notification to application");
                }
                MainEvent::Pause => {
                    debug!("App Paused - stopped running");
                    self.running = false;
                }
                MainEvent::Stop => {
                    // XXX: how to forward this state to applications?
                    warn!("TODO: forward onStop notification to application");
                }
                MainEvent::Destroy => {
                    // XXX: maybe exit mainloop to drop things before being
                    // killed by the OS?
                    warn!("TODO: forward onDestroy notification to application");
                }
                MainEvent::InsetsChanged { .. } => {
                    // XXX: how to forward this state to applications?
                    warn!("TODO: handle Android InsetsChanged notification");
                }
                unknown => {
                    trace!("Unknown MainEvent {unknown:?} (ignored)");
                }
            }
        } else {
            trace!("No main event to handle");
        }

        // temporarily decouple `android_app` from `self` so we aren't holding
        // a borrow of `self` while iterating
        let android_app = self.android_app.clone();

        // Process input events
        match android_app.input_events_iter() {
            Ok(mut input_iter) => loop {
                let read_event =
                    input_iter.next(|event| self.handle_input_event(&android_app, event, callback));

                if !read_event {
                    break;
                }
            },
            Err(err) => {
                tracing::warn!("Failed to get input events iterator: {err:?}");
            }
        }

        // Empty the user event buffer
        {
            while let Ok(event) = self.user_events_receiver.try_recv() {
                callback(crate::event::Event::UserEvent(event), self.window_target());
            }
        }

        if self.running {
            if resized {
                let size = if let Some(native_window) = self.android_app.native_window().as_ref() {
                    let width = native_window.width() as _;
                    let height = native_window.height() as _;
                    PhysicalSize::new(width, height)
                } else {
                    PhysicalSize::new(0, 0)
                };
                let event = event::Event::WindowEvent {
                    window_id: window::WindowId(WindowId),
                    event: event::WindowEvent::Resized(size),
                };
                callback(event, self.window_target());
            }

            pending_redraw |= self.redraw_flag.get_and_reset();
            if pending_redraw {
                pending_redraw = false;
                let event = event::Event::WindowEvent {
                    window_id: window::WindowId(WindowId),
                    event: event::WindowEvent::RedrawRequested,
                };
                callback(event, self.window_target());
            }
        }

        // This is always the last event we dispatch before poll again
        callback(event::Event::AboutToWait, self.window_target());

        self.pending_redraw = pending_redraw;
    }

    fn handle_input_event<F>(
        &mut self,
        android_app: &AndroidApp,
        event: &InputEvent<'_>,
        callback: &mut F,
    ) -> InputStatus
    where
        F: FnMut(event::Event<T>, &RootAEL),
    {
        let mut input_status = InputStatus::Handled;
        match event {
            InputEvent::MotionEvent(motion_event) => {
                let window_id = window::WindowId(WindowId);
                let device_id = event::DeviceId(DeviceId(motion_event.device_id()));

                let phase = match motion_event.action() {
                    MotionAction::Down | MotionAction::PointerDown => {
                        Some(event::TouchPhase::Started)
                    }
                    MotionAction::Up | MotionAction::PointerUp => Some(event::TouchPhase::Ended),
                    MotionAction::Move => Some(event::TouchPhase::Moved),
                    MotionAction::Cancel => Some(event::TouchPhase::Cancelled),
                    _ => {
                        None // TODO mouse events
                    }
                };
                if let Some(phase) = phase {
                    let pointers: Box<dyn Iterator<Item = android_activity::input::Pointer<'_>>> =
                        match phase {
                            event::TouchPhase::Started | event::TouchPhase::Ended => {
                                Box::new(std::iter::once(
                                    motion_event.pointer_at_index(motion_event.pointer_index()),
                                ))
                            }
                            event::TouchPhase::Moved | event::TouchPhase::Cancelled => {
                                Box::new(motion_event.pointers())
                            }
                        };

                    for pointer in pointers {
                        let location = PhysicalPosition {
                            x: pointer.x() as _,
                            y: pointer.y() as _,
                        };
                        trace!(
                            "Input event {device_id:?}, {phase:?}, loc={location:?}, \
                             pointer={pointer:?}"
                        );
                        let event = event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::Touch(event::Touch {
                                device_id,
                                phase,
                                location,
                                id: pointer.pointer_id() as u64,
                                force: Some(Force::Normalized(pointer.pressure() as f64)),
                            }),
                        };
                        callback(event, self.window_target());
                    }
                }
            }
            InputEvent::KeyEvent(key) => {
                match key.key_code() {
                    // Flag keys related to volume as unhandled. While winit does not have a way for
                    // applications to configure what keys to flag as handled,
                    // this appears to be a good default until winit
                    // can be configured.
                    Keycode::VolumeUp | Keycode::VolumeDown | Keycode::VolumeMute
                        if self.ignore_volume_keys =>
                    {
                        input_status = InputStatus::Unhandled
                    }
                    keycode => {
                        let state = match key.action() {
                            KeyAction::Down => event::ElementState::Pressed,
                            KeyAction::Up => event::ElementState::Released,
                            _ => event::ElementState::Released,
                        };

                        let key_char = keycodes::character_map_and_combine_key(
                            android_app,
                            key,
                            &mut self.combining_accent,
                        );

                        let event = event::Event::WindowEvent {
                            window_id: window::WindowId(WindowId),
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(key.device_id())),
                                event: event::KeyEvent {
                                    state,
                                    physical_key: keycodes::to_physical_key(keycode),
                                    logical_key: keycodes::to_logical(key_char, keycode),
                                    location: keycodes::to_location(keycode),
                                    repeat: key.repeat_count() > 0,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        };
                        callback(event, self.window_target());
                    }
                }
            }
            InputEvent::TextEvent(text) => {
                let window_id = window::WindowId(WindowId);
                if text.text.starts_with(EMPTY_SENTINEL) {
                    return InputStatus::Handled; // 本次是哨兵，跳过不上报
                }
                // 输入回车
                if text.text == "\n" {
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Enter),
                                    logical_key: Key::Named(NamedKey::Enter),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Pressed,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Enter),
                                    logical_key: Key::Named(NamedKey::Enter),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Released,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    return InputStatus::Handled;
                }
                // 退格键
                if text.text.is_empty() {
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Delete),
                                    logical_key: Key::Named(NamedKey::Delete),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Pressed,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    callback(
                        event::Event::WindowEvent {
                            window_id,
                            event: event::WindowEvent::KeyboardInput {
                                device_id: event::DeviceId(DeviceId(0)),
                                event: KeyEvent {
                                    physical_key: PhysicalKey::Code(KeyCode::Backspace),
                                    logical_key: Key::Named(NamedKey::Backspace),
                                    location: KeyLocation::Standard,
                                    state: ElementState::Released,
                                    repeat: false,
                                    text: None,
                                    platform_specific: KeyEventExtra {},
                                },
                                is_synthetic: false,
                            },
                        },
                        self.window_target(),
                    );
                    return InputStatus::Handled;
                }

                let enabled = event::Event::WindowEvent {
                    window_id,
                    event: event::WindowEvent::Ime(event::Ime::Enabled),
                };
                callback(enabled, self.window_target());

                let commit = event::Event::WindowEvent {
                    window_id,
                    event: event::WindowEvent::Ime(event::Ime::Commit(text.text.clone())),
                };
                callback(commit, self.window_target());

                let disabled = event::Event::WindowEvent {
                    window_id,
                    event: event::WindowEvent::Ime(event::Ime::Disabled),
                };
                callback(disabled, self.window_target());

                android_app.set_text_input_state(android_activity::input::TextInputState {
                    text: EMPTY_SENTINEL.to_string(),
                    selection: TextSpan { start: 0, end: 1 },
                    compose_region: None,
                });
            }
            _ => {
                warn!("Unknown android_activity input event {event:?}")
            }
        }

        input_status
    }

    pub fn run<F>(mut self, event_handler: F) -> Result<(), EventLoopError>
    where
        F: FnMut(event::Event<T>, &event_loop::ActiveEventLoop),
    {
        self.run_on_demand(event_handler)
    }

    pub fn run_on_demand<F>(&mut self, mut event_handler: F) -> Result<(), EventLoopError>
    where
        F: FnMut(event::Event<T>, &event_loop::ActiveEventLoop),
    {
        loop {
            match self.pump_events(None, &mut event_handler) {
                PumpStatus::Exit(0) => {
                    break Ok(());
                }
                PumpStatus::Exit(code) => {
                    break Err(EventLoopError::ExitFailure(code));
                }
                _ => {
                    continue;
                }
            }
        }
    }

    pub fn pump_events<F>(&mut self, timeout: Option<Duration>, mut callback: F) -> PumpStatus
    where
        F: FnMut(event::Event<T>, &RootAEL),
    {
        if !self.loop_running {
            self.loop_running = true;

            // Reset the internal state for the loop as we start running to
            // ensure consistent behaviour in case the loop runs and exits more
            // than once
            self.pending_redraw = false;
            self.cause = StartCause::Init;

            // run the initial loop iteration
            self.single_iteration(None, &mut callback);
        }

        // Consider the possibility that the `StartCause::Init` iteration could
        // request to Exit
        if !self.exiting() {
            self.poll_events_with_timeout(timeout, &mut callback);
        }
        if self.exiting() {
            self.loop_running = false;

            callback(event::Event::LoopExiting, self.window_target());

            PumpStatus::Exit(0)
        } else {
            PumpStatus::Continue
        }
    }

    fn poll_events_with_timeout<F>(&mut self, mut timeout: Option<Duration>, mut callback: F)
    where
        F: FnMut(event::Event<T>, &RootAEL),
    {
        let start = Instant::now();

        self.pending_redraw |= self.redraw_flag.get_and_reset();

        timeout =
            if self.running && (self.pending_redraw || self.user_events_receiver.has_incoming()) {
                // If we already have work to do then we don't want to block on the next poll
                Some(Duration::ZERO)
            } else {
                let control_flow_timeout = match self.control_flow() {
                    ControlFlow::Wait => None,
                    ControlFlow::Poll => Some(Duration::ZERO),
                    ControlFlow::WaitUntil(wait_deadline) => {
                        Some(wait_deadline.saturating_duration_since(start))
                    }
                };

                min_timeout(control_flow_timeout, timeout)
            };

        let app = self.android_app.clone(); // Don't borrow self as part of poll expression
        app.poll_events(timeout, |poll_event| {
            let mut main_event = None;

            match poll_event {
                android_activity::PollEvent::Wake => {
                    // In the X11 backend it's noted that too many false-positive wake ups
                    // would cause the event loop to run continuously. They handle this by
                    // re-checking for pending events (assuming they cover all
                    // valid reasons for a wake up).
                    //
                    // For now, user_events and redraw_requests are the only reasons to expect
                    // a wake up here so we can ignore the wake up if there are no events/requests.
                    // We also ignore wake ups while suspended.
                    self.pending_redraw |= self.redraw_flag.get_and_reset();
                    if !self.running
                        || (!self.pending_redraw && !self.user_events_receiver.has_incoming())
                    {
                        return;
                    }
                }
                android_activity::PollEvent::Timeout => {}
                android_activity::PollEvent::Main(event) => {
                    main_event = Some(event);
                }
                unknown_event => {
                    warn!("Unknown poll event {unknown_event:?} (ignored)");
                }
            }

            self.cause = match self.control_flow() {
                ControlFlow::Poll => StartCause::Poll,
                ControlFlow::Wait => StartCause::WaitCancelled {
                    start,
                    requested_resume: None,
                },
                ControlFlow::WaitUntil(deadline) => {
                    if Instant::now() < deadline {
                        StartCause::WaitCancelled {
                            start,
                            requested_resume: Some(deadline),
                        }
                    } else {
                        StartCause::ResumeTimeReached {
                            start,
                            requested_resume: deadline,
                        }
                    }
                }
            };

            self.single_iteration(main_event, &mut callback);
        });
    }

    pub fn window_target(&self) -> &event_loop::ActiveEventLoop {
        &self.window_target
    }

    pub fn create_proxy(&self) -> EventLoopProxy<T> {
        EventLoopProxy {
            user_events_sender: self.user_events_sender.clone(),
            waker: self.android_app.create_waker(),
        }
    }

    fn control_flow(&self) -> ControlFlow {
        self.window_target.p.control_flow()
    }

    fn exiting(&self) -> bool {
        self.window_target.p.exiting()
    }
}

pub struct EventLoopProxy<T: 'static> {
    user_events_sender: mpsc::Sender<T>,
    waker: AndroidAppWaker,
}

impl<T: 'static> Clone for EventLoopProxy<T> {
    fn clone(&self) -> Self {
        EventLoopProxy {
            user_events_sender: self.user_events_sender.clone(),
            waker: self.waker.clone(),
        }
    }
}

impl<T> EventLoopProxy<T> {
    pub fn send_event(&self, event: T) -> Result<(), event_loop::EventLoopClosed<T>> {
        self.user_events_sender
            .send(event)
            .map_err(|err| event_loop::EventLoopClosed(err.0))?;
        self.waker.wake();
        Ok(())
    }
}

pub struct ActiveEventLoop {
    pub(crate) app: AndroidApp,
    control_flow: Cell<ControlFlow>,
    exit: Cell<bool>,
    redraw_requester: RedrawRequester,
}

impl ActiveEventLoop {
    pub fn primary_monitor(&self) -> Option<MonitorHandle> {
        Some(MonitorHandle::new(self.app.clone()))
    }

    pub fn create_custom_cursor(&self, source: CustomCursorSource) -> CustomCursor {
        let _ = source.inner;
        CustomCursor {
            inner: PlatformCustomCursor,
        }
    }

    pub fn available_monitors(&self) -> VecDeque<MonitorHandle> {
        let mut v = VecDeque::with_capacity(1);
        v.push_back(MonitorHandle::new(self.app.clone()));
        v
    }

    #[inline]
    pub fn listen_device_events(&self, _allowed: DeviceEvents) {}

    #[cfg(feature = "rwh_05")]
    #[inline]
    pub fn raw_display_handle_rwh_05(&self) -> rwh_05::RawDisplayHandle {
        rwh_05::RawDisplayHandle::Android(rwh_05::AndroidDisplayHandle::empty())
    }

    #[inline]
    pub fn system_theme(&self) -> Option<Theme> {
        None
    }

    #[cfg(feature = "rwh_06")]
    #[inline]
    pub fn raw_display_handle_rwh_06(
        &self,
    ) -> Result<rwh_06::RawDisplayHandle, rwh_06::HandleError> {
        Ok(rwh_06::RawDisplayHandle::Android(
            rwh_06::AndroidDisplayHandle::new(),
        ))
    }

    pub(crate) fn set_control_flow(&self, control_flow: ControlFlow) {
        self.control_flow.set(control_flow)
    }

    pub(crate) fn control_flow(&self) -> ControlFlow {
        self.control_flow.get()
    }

    pub(crate) fn exit(&self) {
        self.exit.set(true)
    }

    pub(crate) fn clear_exit(&self) {
        self.exit.set(false)
    }

    pub(crate) fn exiting(&self) -> bool {
        self.exit.get()
    }

    pub(crate) fn owned_display_handle(&self) -> OwnedDisplayHandle {
        OwnedDisplayHandle
    }
}

#[derive(Clone)]
pub(crate) struct OwnedDisplayHandle;

impl OwnedDisplayHandle {
    #[cfg(feature = "rwh_05")]
    #[inline]
    pub fn raw_display_handle_rwh_05(&self) -> rwh_05::RawDisplayHandle {
        rwh_05::AndroidDisplayHandle::empty().into()
    }

    #[cfg(feature = "rwh_06")]
    #[inline]
    pub fn raw_display_handle_rwh_06(
        &self,
    ) -> Result<rwh_06::RawDisplayHandle, rwh_06::HandleError> {
        Ok(rwh_06::AndroidDisplayHandle::new().into())
    }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub(crate) struct WindowId;

impl WindowId {
    pub const fn dummy() -> Self {
        WindowId
    }
}

impl From<WindowId> for u64 {
    fn from(_: WindowId) -> Self {
        0
    }
}

impl From<u64> for WindowId {
    fn from(_: u64) -> Self {
        Self
    }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DeviceId(i32);

impl DeviceId {
    pub const fn dummy() -> Self {
        DeviceId(0)
    }
}

#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct PlatformSpecificWindowAttributes;

pub(crate) struct Window {
    app: AndroidApp,
    redraw_requester: RedrawRequester,
}

impl Window {
    pub(crate) fn new(
        el: &ActiveEventLoop,
        _window_attrs: window::WindowAttributes,
    ) -> Result<Self, error::OsError> {
        // FIXME this ignores requested window attributes

        Ok(Self {
            app: el.app.clone(),
            redraw_requester: el.redraw_requester.clone(),
        })
    }

    pub(crate) fn maybe_queue_on_main(&self, f: impl FnOnce(&Self) + Send + 'static) {
        f(self)
    }

    pub(crate) fn maybe_wait_on_main<R: Send>(&self, f: impl FnOnce(&Self) -> R + Send) -> R {
        f(self)
    }

    pub fn id(&self) -> WindowId {
        WindowId
    }

    pub fn primary_monitor(&self) -> Option<MonitorHandle> {
        Some(MonitorHandle::new(self.app.clone()))
    }

    pub fn available_monitors(&self) -> VecDeque<MonitorHandle> {
        let mut v = VecDeque::with_capacity(1);
        v.push_back(MonitorHandle::new(self.app.clone()));
        v
    }

    pub fn current_monitor(&self) -> Option<MonitorHandle> {
        Some(MonitorHandle::new(self.app.clone()))
    }

    pub fn scale_factor(&self) -> f64 {
        MonitorHandle::new(self.app.clone()).scale_factor()
    }

    pub fn request_redraw(&self) {
        self.redraw_requester.request_redraw()
    }

    pub fn pre_present_notify(&self) {}

    pub fn inner_position(&self) -> Result<PhysicalPosition<i32>, error::NotSupportedError> {
        Err(error::NotSupportedError::new())
    }

    pub fn outer_position(&self) -> Result<PhysicalPosition<i32>, error::NotSupportedError> {
        Err(error::NotSupportedError::new())
    }

    pub fn set_outer_position(&self, _position: Position) {
        // no effect
    }

    pub fn inner_size(&self) -> PhysicalSize<u32> {
        self.outer_size()
    }

    pub fn request_inner_size(&self, _size: Size) -> Option<PhysicalSize<u32>> {
        Some(self.inner_size())
    }

    pub fn outer_size(&self) -> PhysicalSize<u32> {
        MonitorHandle::new(self.app.clone()).size()
    }

    pub fn set_min_inner_size(&self, _: Option<Size>) {}

    pub fn set_max_inner_size(&self, _: Option<Size>) {}

    pub fn resize_increments(&self) -> Option<PhysicalSize<u32>> {
        None
    }

    pub fn set_resize_increments(&self, _increments: Option<Size>) {}

    pub fn set_title(&self, _title: &str) {}

    pub fn set_transparent(&self, _transparent: bool) {}

    pub fn set_blur(&self, _blur: bool) {}

    pub fn set_visible(&self, _visibility: bool) {}

    pub fn is_visible(&self) -> Option<bool> {
        None
    }

    pub fn set_resizable(&self, _resizeable: bool) {}

    pub fn is_resizable(&self) -> bool {
        false
    }

    pub fn set_enabled_buttons(&self, _buttons: WindowButtons) {}

    pub fn enabled_buttons(&self) -> WindowButtons {
        WindowButtons::all()
    }

    pub fn set_minimized(&self, _minimized: bool) {}

    pub fn is_minimized(&self) -> Option<bool> {
        None
    }

    pub fn set_maximized(&self, _maximized: bool) {}

    pub fn is_maximized(&self) -> bool {
        false
    }

    pub fn set_fullscreen(&self, _monitor: Option<Fullscreen>) {
        warn!("Cannot set fullscreen on Android");
    }

    pub fn fullscreen(&self) -> Option<Fullscreen> {
        None
    }

    pub fn set_decorations(&self, _decorations: bool) {}

    pub fn is_decorated(&self) -> bool {
        true
    }

    pub fn set_window_level(&self, _level: WindowLevel) {}

    pub fn set_window_icon(&self, _window_icon: Option<crate::icon::Icon>) {}

    pub fn set_ime_cursor_area(&self, _position: Position, _size: Size) {}

    pub fn set_ime_allowed(&self, allowed: bool) {
        if allowed {
            self.app.show_soft_input(true);
        } else {
            self.app.hide_soft_input(true);
        }
    }

    pub fn set_ime_purpose(&self, _purpose: ImePurpose) {}

    pub fn focus_window(&self) {}

    pub fn request_user_attention(&self, _request_type: Option<window::UserAttentionType>) {}

    pub fn set_cursor(&self, _: Cursor) {}

    pub fn set_cursor_position(&self, _: Position) -> Result<(), error::ExternalError> {
        Err(error::ExternalError::NotSupported(
            error::NotSupportedError::new(),
        ))
    }

    pub fn set_cursor_grab(&self, _: CursorGrabMode) -> Result<(), error::ExternalError> {
        Err(error::ExternalError::NotSupported(
            error::NotSupportedError::new(),
        ))
    }

    pub fn set_cursor_visible(&self, _: bool) {}

    pub fn drag_window(&self) -> Result<(), error::ExternalError> {
        Err(error::ExternalError::NotSupported(
            error::NotSupportedError::new(),
        ))
    }

    pub fn drag_resize_window(
        &self,
        _direction: ResizeDirection,
    ) -> Result<(), error::ExternalError> {
        Err(error::ExternalError::NotSupported(
            error::NotSupportedError::new(),
        ))
    }

    #[inline]
    pub fn show_window_menu(&self, _position: Position) {}

    pub fn set_cursor_hittest(&self, _hittest: bool) -> Result<(), error::ExternalError> {
        Err(error::ExternalError::NotSupported(
            error::NotSupportedError::new(),
        ))
    }

    #[cfg(feature = "rwh_04")]
    pub fn raw_window_handle_rwh_04(&self) -> rwh_04::RawWindowHandle {
        use rwh_04::HasRawWindowHandle;

        if let Some(native_window) = self.app.native_window().as_ref() {
            native_window.raw_window_handle()
        } else {
            panic!(
                "Cannot get the native window, it's null and will always be null before \
                 Event::Resumed and after Event::Suspended. Make sure you only call this function \
                 between those events."
            );
        }
    }

    #[cfg(feature = "rwh_05")]
    pub fn raw_window_handle_rwh_05(&self) -> rwh_05::RawWindowHandle {
        use rwh_05::HasRawWindowHandle;

        if let Some(native_window) = self.app.native_window().as_ref() {
            native_window.raw_window_handle()
        } else {
            panic!(
                "Cannot get the native window, it's null and will always be null before \
                 Event::Resumed and after Event::Suspended. Make sure you only call this function \
                 between those events."
            );
        }
    }

    #[cfg(feature = "rwh_05")]
    pub fn raw_display_handle_rwh_05(&self) -> rwh_05::RawDisplayHandle {
        rwh_05::RawDisplayHandle::Android(rwh_05::AndroidDisplayHandle::empty())
    }

    #[cfg(feature = "rwh_06")]
    // Allow the usage of HasRawWindowHandle inside this function
    #[allow(deprecated)]
    pub fn raw_window_handle_rwh_06(&self) -> Result<rwh_06::RawWindowHandle, rwh_06::HandleError> {
        use rwh_06::HasRawWindowHandle;

        if let Some(native_window) = self.app.native_window().as_ref() {
            native_window.raw_window_handle()
        } else {
            tracing::error!(
                "Cannot get the native window, it's null and will always be null before \
                 Event::Resumed and after Event::Suspended. Make sure you only call this function \
                 between those events."
            );
            Err(rwh_06::HandleError::Unavailable)
        }
    }

    #[cfg(feature = "rwh_06")]
    pub fn raw_display_handle_rwh_06(
        &self,
    ) -> Result<rwh_06::RawDisplayHandle, rwh_06::HandleError> {
        Ok(rwh_06::RawDisplayHandle::Android(
            rwh_06::AndroidDisplayHandle::new(),
        ))
    }

    pub fn config(&self) -> ConfigurationRef {
        self.app.config()
    }

    pub fn content_rect(&self) -> Rect {
        self.app.content_rect()
    }

    pub fn set_theme(&self, _theme: Option<Theme>) {}

    pub fn theme(&self) -> Option<Theme> {
        None
    }

    pub fn set_content_protected(&self, _protected: bool) {}

    pub fn has_focus(&self) -> bool {
        HAS_FOCUS.load(Ordering::Relaxed)
    }

    pub fn title(&self) -> String {
        String::new()
    }

    pub fn reset_dead_keys(&self) {}
}

#[derive(Default, Clone, Debug)]
pub struct OsError;

use std::fmt::{self, Display, Formatter};
impl Display for OsError {
    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result<(), fmt::Error> {
        write!(fmt, "Android OS Error")
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct MonitorHandle {
    app: AndroidApp,
}
impl PartialOrd for MonitorHandle {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl Ord for MonitorHandle {
    fn cmp(&self, _other: &Self) -> std::cmp::Ordering {
        std::cmp::Ordering::Equal
    }
}

impl MonitorHandle {
    pub(crate) fn new(app: AndroidApp) -> Self {
        Self { app }
    }

    pub fn name(&self) -> Option<String> {
        Some("Android Device".to_owned())
    }

    pub fn size(&self) -> PhysicalSize<u32> {
        if let Some(native_window) = self.app.native_window() {
            PhysicalSize::new(native_window.width() as _, native_window.height() as _)
        } else {
            PhysicalSize::new(0, 0)
        }
    }

    pub fn position(&self) -> PhysicalPosition<i32> {
        (0, 0).into()
    }

    pub fn scale_factor(&self) -> f64 {
        self.app
            .config()
            .density()
            .map(|dpi| dpi as f64 / 160.0)
            .unwrap_or(1.0)
    }

    pub fn refresh_rate_millihertz(&self) -> Option<u32> {
        // FIXME no way to get real refresh rate for now.
        None
    }

    pub fn video_modes(&self) -> impl Iterator<Item = VideoModeHandle> {
        let size = self.size().into();
        // FIXME this is not the real refresh rate
        // (it is guaranteed to support 32 bit color though)
        std::iter::once(VideoModeHandle {
            size,
            bit_depth: 32,
            refresh_rate_millihertz: 60000,
            monitor: self.clone(),
        })
    }
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct VideoModeHandle {
    size: (u32, u32),
    bit_depth: u16,
    refresh_rate_millihertz: u32,
    monitor: MonitorHandle,
}

impl VideoModeHandle {
    pub fn size(&self) -> PhysicalSize<u32> {
        self.size.into()
    }

    pub fn bit_depth(&self) -> u16 {
        self.bit_depth
    }

    pub fn refresh_rate_millihertz(&self) -> u32 {
        self.refresh_rate_millihertz
    }

    pub fn monitor(&self) -> MonitorHandle {
        self.monitor.clone()
    }
}

```

GameActivity

```kotlin
package com.dqq.dqwm

import android.os.Bundle
import android.view.View
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.google.androidgamesdk.GameActivity

class MainActivity : GameActivity() {
    companion object {
        init {
            System.loadLibrary("dqwm")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // 告诉系统：我不要延伸到系统栏
        window.setDecorFitsSystemWindows(false)

        // 设置内容区域避让系统栏
        ViewCompat.setOnApplyWindowInsetsListener(window.decorView) { view, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }
    }

    override fun onWindowFocusChanged(hasFocus: Boolean) {
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus) {
            hideSystemUi()
        }
    }

    private fun hideSystemUi() {
        val decorView = window.decorView
        decorView.systemUiVisibility = (
                //View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY // 屏幕边缘滑出后，系统只会临时显示
                View.SYSTEM_UI_FLAG_LAYOUT_STABLE   //布局稳定,隐藏了，也继续为我保留同样的窗口
                // or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // 把导航栏也算进布局区域
                // or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN //允许内容画到状态栏背后；系统不再给状态栏留顶边距
                // or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION //立即隐藏导航栏（底部三键/手势条）。
                //or View.SYSTEM_UI_FLAG_FULLSCREEN //立即隐藏状态栏（时间、电量、通知图标那一行）
        )
    }
}


```

# 2025-11-08 V1.0.0

```rust
use bevy::{
    color::palettes::css::RED,
    diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin},
    prelude::*,
};
use bevy_inspector_egui::{bevy_egui::EguiPlugin, quick::WorldInspectorPlugin};

#[bevy_main]
pub fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins.set(WindowPlugin {
                primary_window: Some(Window {
                    title: "道起微末".into(),
                    name: Some("道起微末".into()),
                    position: WindowPosition::Centered(MonitorSelection::Primary), // 居中
                    resolution: (300, 533).into(),                                 // 窗口大小
                    ..default()
                }),
                ..default()
            }),
            LogDiagnosticsPlugin::default(),
            FrameTimeDiagnosticsPlugin::default(),
        ))
        .add_plugins((EguiPlugin::default(), WorldInspectorPlugin::new()))
        .add_systems(Startup, setup)
        .add_systems(Update, button_system)
        .run();
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    commands.spawn(Camera2d);

    commands.spawn(bottom_navigation()).with_children(|parent| {
        parent.spawn((nav_button("资源"),));
        parent.spawn((nav_button("游戏"),));
        parent.spawn((nav_button("设置"),));
        parent.spawn((nav_button("关于"),));
    });

    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            position_type: PositionType::Absolute,
            ..default()
        },
        ImageNode {
            image: asset_server.load("bg.jpg").into(),
            ..default()
        },
        ZIndex(-99999),
    ));
    // 放一个文本测试
    commands.spawn((
        Text::new("测试"),
        TextFont {
            font_size: 32.0,
            ..default()
        },
        Test11,
    ));
}

#[derive(Component)]
struct Test11;

// 实现底部导航

#[derive(Component)]
struct BottomNavigation;

//  底部导航按钮
#[derive(Component)]
struct NavButton;

fn bottom_navigation() -> impl Bundle {
    (
        Node {
            width: percent(100),
            height: Val::Auto,
            position_type: PositionType::Absolute, // 关键：绝对定位
            bottom: Val::Px(0.),                   // 贴底
            left: Val::Px(0.),                     // 从左开始
            flex_direction: FlexDirection::Row,    // 关键 1：横向排列
            column_gap: Val::Px(5.0),              // 列间距
            justify_content: JustifyContent::SpaceEvenly, // 关键 2：间距均分
            align_items: AlignItems::Center,       // 垂直居中

            padding: UiRect {
                // 边距
                left: Val::Px(0.0),
                right: Val::Px(0.0),
                top: Val::Px(8.0),
                bottom: Val::Px(8.0),
            },
            ..default()
        },
        BottomNavigation,
        ZIndex(99999),
    )
}

/// 单个子按钮：flex_grow = 1 保证等宽
fn nav_button(text: &str) -> impl Bundle {
    // 外层容器：处理宽度、边距、flex_grow
    (
        Node {
            flex_grow: 1.,
            height: percent(100.),
            margin: UiRect::all(Val::Px(3.0)), // 边距在外层
            ..default()
        },
        // 内层容器：处理边框和内容
        children![(
            Node {
                width: percent(100.), // 内层占满外层
                height: percent(100.),
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                border: UiRect::all(Val::Px(0.5)), // 边框在内层
                ..default()
            },
            BorderColor::all(Color::WHITE),
            BackgroundColor(Color::srgba(0., 0., 255., 1.)),
            Button,
            children![(
                Text::new(text),
                TextFont {
                    font_size: 32.0,
                    ..default()
                },
                NavButton
            )],
        )],
    )
}

fn button_system(
    mut interaction_query: Query<(&Interaction, &mut BorderColor, &Children), Changed<Interaction>>,
    mut label_query: Query<&mut Text, With<Test11>>, // 只改标签
    btn_text_q: Query<&Text, Without<Test11>>,       // 只读按钮文字
) {
    // 先获取标签的可变引用
    let mut label = label_query.single_mut().unwrap();

    for (interaction, mut border_color, children) in &mut interaction_query {
        // 获取按钮文字的只读引用
        let btn_text = &**btn_text_q.get(children[0]).unwrap();

        match *interaction {
            Interaction::Pressed => {
                // 修改标签文字
                **label = format!("按钮说：{}", btn_text);
                *border_color = BorderColor::all(RED);
                border_color.set_changed();
            }
            Interaction::Hovered => {
                // 悬停时的逻辑
            }
            Interaction::None => {
                // 无交互时的逻辑
            }
        }
    }
}

```

```toml
[package]
name = "dqwm"
version = "0.1.0"
edition = "2024"

[lib]
name = "dqwm"
path = "src/lib.rs"
crate-type = ["lib","cdylib"]


[[bin]]
name = "dqwm_desktop"
path = "src/main.rs"
required-features = ["desktop"]

[dependencies]
eframe = "0.33.0"
egui = "0.33.0"



[features]
android = []
desktop = []

[profile.release]
opt-level = "z"       # ③ 最高优化
lto = "thin"          # ① 链接秒级
codegen-units = 16    # ② 并行生成
strip = true          # 自动 strip 符号表（Rust 1.77+）


```

# 运行安卓

cargo ndk -t arm64-v8a -o ./jniLibs build --release --features android

#

cargo install -f cargo-binutils #[cfg(feature = "desktop")]

cargo ndk -t arm64-v8a -o ./jniLibs build --release
cargo ndk -t x86_64 -o ./jniLibs build --release

cargo ndk -t x86_64 -o ./jniLibs build --release --features android
cargo ndk -t arm64-v8a -o ./jniLibs build --release --features android

rustup target add x86_64-linux-android
cargo ndk -t arm64-v8a -t x86_64 -o ./jniLibs build --release

use tokio::time::{sleep, Duration,Instant};

pub struct Resource {
pub id: u32, // 资源 ID
pub name: String, // 资源名称
pub value: u128, // 当前值
pub max: u128, // 最大值
pub change: u128, // 变化量
pub interval: u64, // 周期
pub last_tick: u64, // 上一次刷新时间
pub due_tick: u64, // 到期时间
}

use std::{collections::{BTreeMap, HashMap}, sync::Arc};

#[derive(Debug, Clone, Default, PartialEq)] #[warn(dead_code)] //TODO 后面删除
struct DQWMResource {
id: i32, // 唯一标识符
name: String, // 资源名称
description: String, // 资源描述
value: u128, // 资源值
max: u128, // 资源最大值
change: u128, // 资源变化值
interval: u16, // 资源刷新间隔 0 表示不刷新,1000 代表 1 秒更新一次
next_tick: u64, // 下一次到期时间
last_update_at: u64, // 最后一次更新时间
}

impl DQWMResource{

    //设置资源值
    #[inline]
    pub fn set_value(&mut self, value: u128) {
        self.value = (value + self.change).min(self.max);
    }

    // 补收益
    #[inline]
    pub fn catch_up(&mut self) {
        self.set_value( (now_ms() - (self.last_update_at as u128) ) / (self.interval as u128) )
    }

}

struct DQWMResourceMgr{
\_resources: Vec<DQWMResource>, // 资源列表
\_is_stop: bool // 运行状态, 默认 true
}

impl DQWMResourceMgr{

    fn _run(&mut self){
        // 找到最近的一批
        let now =   now_ms();
        let expire:Vec<_> = self._resources.iter()

        .collect();

        expire.iter().for_each(|i| println!("{:?}", i));

    }

}

// 获取当前时间毫秒数 #[inline]
fn now_ms() -> u128 {
use std::time::{SystemTime, UNIX_EPOCH};
SystemTime::now()
.duration_since(UNIX_EPOCH)
.unwrap()
.as_millis()
}

// 资源 ID

fn main() {
let dqwm_resource_mgr = DQWMResourceMgr();
dqwm_resource_mgr.

}

// 添加
cargo add A
// 运行
cargo run

[package]
name = "dqwm"
version = "0.1.0"
edition = "2024"

[dependencies]

# rhai = { version = "1.16", features = ["sync", "serde", "only_i64"] }

# serde = { version = "1.0", features = ["derive"] }

# serde_json = "1.0"

# thiserror = "1.0"

# anyhow = "1.0"

eframe = { version = "0.33.0", features = ["glow"] }
egui = "0.33.0" #
egui_extras = "0.33.0"

#[derive(Debug, Clone, Default, PartialEq)]
struct GameResource {
id: i32, // 唯一标识符
name: String, // 资源名称
description: String, // 资源描述
value: i128, // 资源值
max_value: i128, // 资源最大值
change_value: f64, // 资源变化值
current_interval: i8, // 当前资源刷新间隔
interval: i8, // 资源刷新间隔
last_refresh_time: i64, // 最后一次刷新时间
}

// 来源
// #[derive(Debug, Clone, Default, PartialEq)]
// struct Bonus {
// id: i32, // 唯一标识符
// name: String, // 来源名称
// target_ids: Vec<i32>, // 目标资源标识符
// description: String, // 来源描述
// value: i128, // 来源值
// rate: f64, // 来源比例
// area_name: String, // 区域名称
// }

// 来源管理
pub struct BonusManager {
inner: Vec<Bonus>, // 来源列表
}

/// 1. 策划配表，全局只读 #[derive(Debug, Clone, Copy)]
pub struct BaseUnitTemp {
pub id: u32, // id
pub name: &'static str, // 名字
pub base_atk: u128, // 攻击
pub base_hp: u128, // 生命
pub base_def: u128, // 防御
pub base_crit_rate: f64, // 暴击率
pub base_crit_damage: f64, // 暴击伤害
pub base_hit_rate: f64, // 命中率
pub base_dodge_rate: f64, // 闪避率
pub base_attack_speed: f64, // 攻击速度
pub base_life_steal: f64, // 生命偷取
}

/// 2. 账号维度：在基础值上叠加养成、装备、科技等加成
/// 只存“当前值”，不存历史 delta #[derive(Debug, Clone)]
pub struct UnitTemp {
pub base_temp_id: u32, // 对应 BaseUnitTemp.id
pub name: String,
pub atk: u128, // 当前攻击
pub hp: u128,
pub def: u128,
pub crit_rate: f64, // 暴击率
pub crit_damage: f64, // 暴击伤害
pub hit_rate: f64, // 命中率
pub dodge_rate: f64, // 闪避率
pub attack_speed: f64, // 攻击速度
pub life_steal: f64, // 生命偷取
}

#[derive(Debug, Clone)]
pub struct Unit {
pub temp_id: u32,
pub name: String,
pub atk: u128,
pub hp: u128,
pub def: u128,
pub crit_rate: f64, // 暴击率
pub crit_damage: f64, // 暴击伤害
pub hit_rate: f64, // 命中率
pub dodge_rate: f64, // 闪避率
pub attack_speed: f64, // 攻击速度
pub life_steal: f64, // 生命偷取
}

// 动态执行

use rhai::{Engine, Map, AST};
use std::time::Instant;

fn main() {
let engine = Engine::new();
let ast: AST = engine
.compile(r#"
if lv > 10 { #{"1001": 5*lv, "1005": 50*lv} }
else { #{"1001": 2*lv, "1005": 20*lv} }
"#)
.unwrap();

    let mut scope = rhai::Scope::new();
    // 预热一次，避免 AST 懒加载干扰
    scope.push("lv", 15_i64);
    let _: Map = engine.eval_ast_with_scope(&mut scope, &ast).unwrap();

    const N: usize = 10000;
    let start = Instant::now();

    for _ in 0..N {
        // 每次只换变量，不重新编译
        scope.push("lv", 15_i64);
        let _: Map = engine.eval_ast_with_scope(&mut scope, &ast).unwrap();
    }

    let elapsed = start.elapsed();
    println!(
        "1000 次总耗时 {:?}，单次平均 {:?}",
        elapsed,
        elapsed / N as u32
    );

}
